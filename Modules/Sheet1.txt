VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "Sheet1"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = True
Option Explicit

Dim lastCellRange As Range
Dim pieChart As Excel.shape
Dim lineChart As Excel.shape
Dim barChart As Excel.shape
Dim tempAddy As String

'*************************************************************
'*************************************************************
'*                  ShopStatus
'*
'*************************************************************
'*************************************************************


'************************************************************
'*************   Cleanup/Fill Routines   ********************
'************************************************************

Public Sub Cleanup()
    Unprotect PASSWORD:=Config.PASSWORD
    With Range(Cells(1, 1), Cells(400, 8))
        .Clear
        .RowHeight = 18
        .Interior.ColorIndex = 0
        .Borders.LineStyle = xlLineStyleNone
        .Locked = False
    End With
'    Cells.NumberFormat = "@"
    Set lastCellRange = Nothing
    
    Call DeleteImages
    
    'TODO There needs to be something for cleaning out the JobView as well
End Sub

Public Sub DeleteImages()
    Me.Unprotect PASSWORD:=Config.PASSWORD

    On Error Resume Next
    Dim im As Excel.shape
    For Each im In Me.Shapes
        With im.Chart
        .Delete
        End With
        im.Delete
    Next im
    
    Set pieChart = Nothing
    Set lineChart = Nothing
End Sub

Public Sub DestroyPieCharts(Optional destroyLine As Boolean)
    On Error Resume Next
    Me.Shapes("Doughnut").Delete
    If destroyLine = True Then
        Me.Shapes("Line").Delete
    End If
    
'    Dim im As Excel.shape
'    For Each im In Me.Shapes
'        If im.Name = "Doughnut" Then im.Delete  'TODO: placeholder, should be safe since the pie chart is what gets created first
'    Next im
    Set pieChart = Nothing
End Sub

Public Sub DestroyBottomCharts()
    On Error Resume Next
    Me.Shapes("Line").Delete
    Me.Shapes("Bar").Delete
    Set lineChart = Nothing
    Set barChart = Nothing
End Sub

    'Creates the Header Cell Row the Production Machines
Public Sub AddCell(cellName As String)
    If lastCellRange Is Nothing Then
        Set lastCellRange = Range("A1")
    Else
        Set lastCellRange = lastCellRange.Offset(2, 0)
    End If
    
    Dim headerRange As Range
    Set headerRange = Range("A" & lastCellRange.row & ":" & "H" & lastCellRange.row)
    With headerRange
        .Font.ColorIndex = 2
        .Font.Size = 8
        .HorizontalAlignment = xlCenter
        .Interior.color = RGB(128, 128, 128)
    End With
    With lastCellRange
        .Value = cellName
        .Font.Bold = True
        .Font.ColorIndex = 2
        .Font.Size = 11
        .HorizontalAlignment = xlCenter
    End With
    
    lastCellRange.Offset(0, 1).Value = "Machine"
    lastCellRange.Offset(0, 2).Value = "Job#"
    lastCellRange.Offset(0, 3).Value = "Drawing#"
    lastCellRange.Offset(0, 4).Value = "Part#"
    lastCellRange.Offset(0, 5).Value = "Rev"
    lastCellRange.Offset(0, 6).Value = "Desc"
    lastCellRange.Offset(0, 7).Value = "Status"

    lastCellRange.EntireRow.RowHeight = 14

End Sub

    'Add a Machine and Job Underneath one of the Cells
Public Sub AddJob(jobInfo() As Variant)
    'TODO: check if the lastCellRange is Nothing, in which case, we should error out
    Set lastCellRange = lastCellRange.Offset(1, 0)
    Dim jobRange As Range
    Set jobRange = Range("B" & lastCellRange.row & ":" & "H" & lastCellRange.row)
    jobRange = jobInfo
    jobRange.HorizontalAlignment = xlCenter
    With jobRange.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .color = RGB(128, 128, 128)
        .Weight = xlThin
    End With
    
    Range("G" & lastCellRange.row).HorizontalAlignment = xlLeft
    If lastCellRange.Offset(0, 7).Value = "[Setup]" Then
        lastCellRange.EntireRow.Font.color = RGB(128, 128, 128)
    End If
    
        'Put some dummy text under status to prevent desc. overflow
    With Cells(lastCellRange.row, 8)
        If .Value = "" Then
            .Value = "."
        End If
        .Font.color = RGB(255, 255, 255)
    End With
    
    SetPicture Range("H" & lastCellRange.row)
    
    
End Sub

Private Sub SetPicture(Target As Range)
    Dim picture As Object
    Dim picAddy As String
    Dim colorFill As Single
    
        'TODO: we want to establish a warning sign based on the desired amount of inspections to alert the PQCI
    Select Case Target.Value
        Case "[Setup]"   'When setup is not 100%, There isnt going to be much to see here
            picAddy = "https://cdn.hubblecontent.osi.office.net/icons/publish/icons_gears/gears.svg"
            colorFill = RGB(128, 128, 128)
        Case "[Production]"  'TODO: might get rid of this, I can usually assume that its in production
'            picAddy = "https://cdn.hubblecontent.osi.office.net/icons/publish/icons_arrowcircle/arrowcircle.svg"
        Case Else  'Question Mark - issue with retriveing the data
            picAddy = "https://cdn.hubblecontent.osi.office.net/icons/publish/icons_questionmark_ltr/questionmark_ltr.svg"
            Exit Sub
    End Select
    
    Target.Value = ""
    If picAddy = "" Then Exit Sub
    Set picture = Shapes.AddPicture(picAddy, False, True, top:=Target.top, left:=Target.left + 15, Height:=20, Width:=20)
    
    If colorFill <> 0 Then
        picture.Fill.ForeColor.RGB = colorFill
    End If
    
End Sub

Public Sub FinishTransfer()
    Protect PASSWORD:=Config.PASSWORD
    tempAddy = lastCellRange.Address
End Sub





'************************************************************
'****************   Event Callbacks   ***********************
'************************************************************



Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    
    If Target.Areas.Count <> 1 Then Exit Sub
    If Target.Count <> 1 Then Exit Sub
    
    
    Dim validSelection As Boolean
    
    
    
    'TODO: temp manual setting until we figure out what to do with this missing reference
    'TODO dont hardset the range here, must find it manually
    If lastCellRange Is Nothing Then
        Set lastCellRange = GetLastCell()
    End If
    
    On Error GoTo selectionErr
    
    Application.EnableEvents = False
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Me.Unprotect Config.PASSWORD
    
        'If user selected information about the active job in the Viewport
    If Not (Application.Intersect(Range("K2:K8"), Target) Is Nothing) Then
        Range("J2:J8").Value = ""
        Target.Offset(0, -1).Value = ">"
        Range("K2:N8").Interior.ColorIndex = 0
        Range(Target.Address & ":N" & Target.row).Interior.color = RGB(101, 215, 255)
        
        Select Case Target.Address
            Case "$K$2"  'Setup
            
            Case "$K$4" 'Last Insepction
                Call CreateInspBarChart
                Call CreateInspDoughnut
            
            Case "$K$6"  'Parts Completed /Required
                Call CreateLaborQtyDoughnut
                Call CreateLaborQtyTimeSeries
            Case "$K$8"  'Hours Remaining
                Call CreatePrdHoursDoughnut
            Case Else
                'Doesn't make sense
        End Select
        
    
    Else  'If user selected a new job Row, these are the only other unprotected cells
        Dim subCell As Range
        Dim jobRange As Range
        Set jobRange = GetJobCells() 'Range("A1:" & lastCellRange.Address).Offset(0, 1)
        
        'Cell Highlighting
        For Each subCell In jobRange
                'reset previously highlighted cells to blank
            If subCell.Interior.color = RGB(101, 215, 255) Then
                Range("B" & subCell.row & ":" & "H" & subCell.row).Interior.ColorIndex = 0
            End If
    
                'set the intersection row of the selected job to blue bg
                'TODO: EntireRow checks are slow, we should only have a selectable area anyway, try and limit this
            If Not (Application.Intersect(subCell, Target.EntireRow) Is Nothing) Then
                Range("B" & subCell.row & ":" & "H" & subCell.row).Interior.color = RGB(101, 215, 255)
                validSelection = True
            End If
            
'            If Not (Application.Intersect(subCell, Target.EntireRow) Is Nothing) And subCell.Interior.color <> RGB(128, 128, 128) Then
'                Range("B" & subCell.Row & ":" & "H" & subCell.Row).Interior.color = RGB(101, 215, 255)
'                validSelection = True
'            End If
        Next subCell
        
        If validSelection = False Then GoTo 10  'If they selected a header or something then leave after unsetting the previous selection
        
        Dim jobCell As Range
        Set jobCell = Target.Offset(0, GetCol("Job#") - Target.column)
        If jobCell.Value = "" Then GoTo 10
        Dim rowNum As Integer
        rowNum = Sheets("ShopLoad").GetJobInd(jobCell.Value).row
                                                
            'Update the JobInfo Viewport
        Call updatedJobInfo(rowNumber:=rowNum, jobCell:=jobCell)
                                                
        
            'What job Information do we currently want called?
                'The appropriate charts will be generated depending on this
                'If this function returned nothing then Hours Remaining will have been selected by default
        Dim infoRange As Range
        Set infoRange = GetJobInfoSelection()
        
        Select Case infoRange.Address
            Case "$K$2"  'Setup Info
            
            Case "$K$4"  'Last Inspection Info
                Call CreateInspBarChart(jobCell:=jobCell)
                Call CreateInspDoughnut(jobCell:=jobCell)
            
            Case "$K$6"  'Parts Completed / Required
                Call CreateLaborQtyDoughnut(jobCell:=jobCell)
                Call CreateLaborQtyTimeSeries(jobCell:=jobCell)
            
            Case "$K$8"  'Hours Remaining
                Call CreatePrdHoursDoughnut(jobCell:=jobCell)
            Case Else
                'Shouldnt happen
        End Select
        
    End If
    
10
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Me.Protect Config.PASSWORD
    Exit Sub
    
selectionErr:
    If Err.Number <> vbObjectError + 1000 Then
        Call DeleteImages
        MsgBox Err.Number & vbCrLf & Err.Description
    End If
    GoTo 10
End Sub

'************************************************************
'****************   JobInfo Viewport   **********************
'************************************************************

'Called by _SelectionChange
Private Sub updatedJobInfo(rowNumber As Integer, jobCell As Range)
    Dim indRange As Range
    Set indRange = Sheets("ShopLoad").Range("A" & rowNumber)
    
    Range("K1").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("JobNum") - indRange.column).Value  'Job# Header
    Range("K3").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("FA Type") - indRange.column).Value
    Range("M3").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("Set%") - indRange.column).Value & "%"
    
    If Range("M3").Value = "100%" Then
        Range("N3").Value = "þ"
    Else
        Range("N3").Value = "o"
    End If
    
    Range("N5").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("AQL") - indRange.column).Value
    Range("K7").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("Qty Complete") - indRange.column).Value
    Range("M7").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("Run Qty") - indRange.column).Value
    Range("N8").Value = indRange.Offset(0, Sheets("ShopLoad").GetCol("Est Rem Hrs") - indRange.column).Value
    
    
    'TODO: This will also require an update to the sparkline in the Parts Completed/ Required section
    Dim colors() As Variant
    Dim indCell As Range
    Dim valRange As Range
    Dim opNum As String
    Set indCell = Sheets("ShopLoad").GetJobInd(jobCell.Value)
    opNum = indCell.Offset(0, Sheets("ShopLoad").GetCol("Op Seq") - indCell.column).Value
    
    On Error GoTo NoInfoErr
    Set valRange = Sheets("ProdInfo").GetProductionLaborData(jobNum:=jobCell.Value, opNum:=opNum, colors:=colors)
    Set valRange = valRange.Offset(0, 1)
    With Range("N7")
        .SparklineGroups.Clear
        .SparklineGroups.Add Type:=xlSparkLine, SourceData:="ProdInfo!" & valRange.Address
        '.SparklineGroups.Item(1).SeriesColor.color = 9592887
    End With
    'GetProductionLaborData(jobNum:=jobCell.Value, opNum:=opNum, colors:=colors)
    
    Exit Sub
    
NoInfoErr:
        'No Production information, still set a chart of empty values anyways
    If Err.Number = vbObjectError + 1000 Then
        Range("N7").SparklineGroups.Clear
        Exit Sub
    Else
        On Error GoTo 0   'TODO: still might want to clear up the charts in this situation
        Err.Raise Number:=vbObjectError + 1100, Description:="Problem with fetching the Data for this Job."
    End If

End Sub

'Called by _SelectionChange
    'Find out which of the Job SubCategories is currently active, we switch on this to figure out what chart info to load
Private Function GetJobInfoSelection() As Range
    Dim info As Range
    Set info = Range("K2, K4, K6, K8")
    Dim subCell As Range
    
    For Each subCell In info
        If subCell.Interior.color = RGB(101, 215, 255) And subCell.Offset(0, -1).Value = ">" Then
            Set GetJobInfoSelection = subCell
        End If
    Next subCell
    
    'If we didnt have anything for JobInfo selected already, we should select the hours remaining and let the event callback handle it
        'from there. Should ultimately end up calling the same function
    If GetJobInfoSelection Is Nothing Then
            Range("K8").Select
    End If
    
End Function

'************************************************************
'**************   Chart Call Routines   *********************
'************************************************************
'These are called by the _onSelectionChange
'Get the job cell and then create the data structures and pass to Main Chart Creation Routines
    'For them to do their thing


Private Sub CreatePrdHoursDoughnut(Optional jobCell As Range)
    If jobCell Is Nothing Then
        Set jobCell = GetActiveJob()
        If jobCell Is Nothing Then Exit Sub
    End If
    

    Dim indCell As Range
    Dim lastActiveCell As Range
    Set indCell = Sheets("ShopLoad").GetJobInd(jobCell.Value)
    If indCell Is Nothing Then Err.Raise Number:=vbObjectError + 1100, Description:="Can't find this job on the Shop Load"
    Set lastActiveCell = activeCell
        
    jobCell.Activate   'Charts are created using ranges around the active cell, need to select something that wont cause errors then come back to the main cell

    Dim Yrange As Range
    Dim Xrange As Range
    Dim colors(1 To 2, 1 To 3) As Variant
    
    colors(1, 3) = Config.COLOR_1
    colors(2, 3) = Config.COLOR_8
    
    Set Yrange = indCell.Offset(0, Sheets("ShopLoad").GetCol("Prod Hrs") - indCell.column)
    Set Yrange = Application.Union(Yrange, Yrange.Offset(0, 1))
    
    Set Xrange = Sheets("ShopLoad").Range("$I$1:$J$1")
    
    Call DestroyPieCharts(destroyLine:=True)
    Call CreateDoughnutChart(Xrange:=Xrange, Yrange:=Yrange, colors:=colors)

    lastActiveCell.Activate
    
End Sub

Private Sub CreateLaborQtyDoughnut(Optional jobCell As Range)
    If jobCell Is Nothing Then
        Set jobCell = GetActiveJob()
        If jobCell Is Nothing Then Exit Sub
    End If
    
    Dim indCell As Range
    Dim opNum As String
    Dim colors() As Variant
    Dim lastActiveCell As Range
    Set indCell = Sheets("ShopLoad").GetJobInd(jobCell.Value)
    opNum = indCell.Offset(0, Sheets("ShopLoad").GetCol("Op Seq") - indCell.column).Value
    
    Set lastActiveCell = activeCell
       
    jobCell.Activate
       
    Dim Xrange As Range
    Dim Yrange As Range
    
    On Error GoTo NoInfoErr
        'Will raise a specific error that we can capture if there was no production qty
            'This first call is just to set the colors
    Set Xrange = Sheets("ProdInfo").GetProductionLaborData(jobNum:=jobCell.Value, opNum:=opNum, colors:=colors)
    Set Xrange = Sheets("ProdInfo").GetProductionLaborDataSUM(jobNum:=jobCell.Value)
    
    Set Yrange = Xrange.Offset(0, 1)
10
    On Error GoTo 0
    Call DestroyPieCharts
    Call CreateDoughnutChart(Xrange:=Xrange, Yrange:=Yrange, colors:=colors)
    
    lastActiveCell.Activate
    
    Exit Sub
    
NoInfoErr:
        'No Production information, still set a chart of empty values anyways
    If Err.Number = vbObjectError + 1000 Then
        GoTo 10
    Else
        On Error GoTo 0
        Err.Raise Number:=vbObjectError + 1100, Description:="Problem with fetching the Data for this Job."
    End If

End Sub



    '***********Work in Progress***************
Private Sub CreateInspDoughnut(Optional jobCell As Range)
    If jobCell Is Nothing Then
        Set jobCell = GetActiveJob()
        If jobCell Is Nothing Then Exit Sub
    End If
    
    Dim lastActiveCell As Range
    Set lastActiveCell = activeCell
       
    jobCell.Activate
       
    Dim Xrange As Range
    Dim Yrange As Range
    Dim colors() As Variant
    
        'Will raise a specific error that we can capture if there was no production qty
            'This first call is just to set the colors
    Set Yrange = Sheets("MeasurementInfo").GetEmpInspDataSUM(jobNum:=jobCell.Value, empRange:=Xrange, colors:=colors)
    If (Not colors) = -1 Then GoTo 10  'Theres nothing to set, let the chart routines setup the default NO DATA

    'Check if the reutrned range is nothing
    Dim fmtColors() As Variant
    ReDim Preserve fmtColors(1 To UBound(colors, 2), 1 To 3)
    Dim i As Integer
    For i = 1 To UBound(colors, 2)
        fmtColors(i, 3) = colors(1, i)
    Next i


    On Error GoTo 0
10
    Call DestroyPieCharts
    Call CreateDoughnutChart(Xrange:=Xrange, Yrange:=Yrange, colors:=fmtColors)
    
    lastActiveCell.Activate
    
    'TODO erorr handle here

End Sub



Private Sub CreateInspBarChart(Optional jobCell As Range)
    If jobCell Is Nothing Then
        Set jobCell = GetActiveJob()
        If jobCell Is Nothing Then Exit Sub
    End If
    
    Dim lastActiveCell As Range
    Dim rtRange As Range
    Dim indCell As Range
    Dim partnum As String
    Dim rev As String
    Dim faType As String
    
    
    Set lastActiveCell = activeCell
    jobCell.Activate
    
    Set indCell = Sheets("ShopLoad").GetJobInd(jobCell.Value)
    partnum = indCell.Offset(0, Sheets("ShopLoad").GetCol("Part#") - indCell.column).Value
    rev = indCell.Offset(0, Sheets("ShopLoad").GetCol("Rev") - indCell.column).Value
    faType = indCell.Offset(0, Sheets("ShopLoad").GetCol("FA Type") - indCell.column).Value
    
    Set rtRange = Sheets("MeasurementInfo").GetEmpInspData(jobNum:=jobCell.Value, partNumber:=partnum, _
                                                    rev:=rev, faType:=faType)
                                                    
    
    
    Dim Yrange As Collection
    Dim empRange As Range
    Dim colorRange As Range
    Dim rtAddy As String
    
    Set Yrange = New Collection
    If rtRange Is Nothing Then GoTo 10 'TODO: handle we couldnt get the job info / there are no routines for this job
    
    
    rtAddy = rtRange.Address
    
    Do
        Dim empCell As Range
        Dim colorCell As Range
        
        Set rtRange = rtRange.Offset(0, 1)
        
        Set empCell = rtRange.Cells(1).Offset(-1, 0)
        If empCell.Value = "" Then GoTo 10
        
        Set colorCell = rtRange.Cells(rtRange.Count).Offset(2, 0)
        
        Yrange.Add rtRange
        
        If empRange Is Nothing Then
            Set empRange = empCell
            Set colorRange = colorCell
        Else
            Set empRange = Application.Union(empRange, empCell)
            Set colorRange = Application.Union(colorRange, colorCell)
        End If
        
    Loop While True
    
10
'    If Yrange.Count = 0 Then Exit Sub 'TODO: handle we didnt have any inspections
    
    Set rtRange = Sheets("MeasurementInfo").Range(rtAddy)
    
    Call DestroyBottomCharts
    CreateBarChart Xrange:=rtRange, Yrange:=Yrange, empRange:=empRange, colorRange:=colorRange
    
    lastActiveCell.Activate
    
'TODO: erorr handlers here
        

End Sub


Private Sub CreateLaborQtyTimeSeries(Optional jobCell As Range)
    If jobCell Is Nothing Then
        Set jobCell = GetActiveJob()
        If jobCell Is Nothing Then Exit Sub
    End If
    
    Dim indCell As Range
    Dim opNum As String
    Dim colors() As Variant
    Dim lastActiveCell As Range
    Set indCell = Sheets("ShopLoad").GetJobInd(jobCell.Value)
    opNum = indCell.Offset(0, Sheets("ShopLoad").GetCol("Op Seq") - indCell.column).Value
    
    Set lastActiveCell = activeCell
    
    jobCell.Activate
    
    Dim Xrange As Range
    Dim Yrange As Range
    Dim empRange As Range
    
    On Error GoTo NoInfoErr
    Set Xrange = Sheets("ProdInfo").GetProductionLaborData(jobNum:=jobCell.Value, opNum:=opNum, colors:=colors)
    If Xrange Is Nothing Then GoTo 10
    Set Yrange = Xrange.Offset(0, 1)
    Set empRange = Xrange.Offset(0, 2)
    
10
    On Error GoTo 0
    Call DestroyBottomCharts
    Call CreateTimeSeriesChart(Xrange:=Xrange, Yrange:=Yrange, empRange:=empRange, colors:=colors)

    lastActiveCell.Activate
    
    Exit Sub
    
NoInfoErr:
        'No Production information, still set a chart of empty values anyways
    If Err.Number = vbObjectError + 1000 Then
        GoTo 10
    Else
        On Error GoTo 0
        Err.Raise Number:=vbObjectError + 1100, Description:="Problem with fetching the Data for this Job."
    End If

End Sub





'************************************************************
'*********   MAIN Chart Creation Routines   *****************
'************************************************************

Public Sub CreateDoughnutChart(Xrange As Range, Yrange As Range, colors() As Variant)
    
    Set pieChart = Me.Shapes.AddChart2(-1, xlDoughnutExploded, left:=850, top:=ActiveWindow.VisibleRange.top + 5, Height:=160, Width:=220)
    pieChart.Name = "Doughnut"
    
    With pieChart.Chart
        If Xrange Is Nothing Or Yrange Is Nothing Then
            .ChartTitle.Caption = "NO DATA"
            .Legend.Delete
            Exit Sub
        Else
            pieChart.Title = ""
            .ChartTitle.Delete
        End If
        .ChartGroups(1).DoughnutHoleSize = 40   'original size was 73
        .Legend.Position = xlRight
        .Legend.Height = 75
        .Legend.Width = 60
        .Legend.top = 40
        .Legend.left = 155
    End With

    
    
        'New/Update Parameters
    With pieChart.Chart
        .SeriesCollection(1).XValues = Xrange
        .SeriesCollection(1).Values = Yrange
        .ApplyDataLabels HasLeaderLines:=False, ShowSeriesName:=False, ShowCategoryName:=False, ShowValue:=True, ShowPercentage:=True
        .SeriesCollection(1).Explosion = 4
        .SeriesCollection(1).DataLabels.Select
        Selection.Format.Fill.Visible = 0
        Selection.Format.Line.Visible = 0
        Selection.Separator = "" & Chr(13) & ""
    End With
    
        'Set Custom colors for the slices, Custom positions for the Data Labels
    With pieChart.Chart.SeriesCollection(1)
        Dim i As Integer
        Dim leftOut As Double
        Dim topOut As Double
        
        For i = 1 To .Points.Count
            .Points(i).Format.Fill.ForeColor.RGB = colors(i, 3)
            .Points(i).DataLabel.Select
            
            leftOut = GetOuterLblLeft(lblLeft:=.Points(i).DataLabel.left, lblTop:=.Points(i).DataLabel.top, lblWidth:=.Points(i).DataLabel.Width, lblHeight:=.Points(i).DataLabel.Height, _
                                chtLeft:=pieChart.Chart.PlotArea.left, chtTop:=pieChart.Chart.PlotArea.top, chtWidth:=pieChart.Chart.PlotArea.Width, chtHeight:=pieChart.Chart.PlotArea.Height, percIncrease:=0.85)
                                
            
            
            topOut = GetOuterLblTop(lblLeft:=.Points(i).DataLabel.left, lblTop:=.Points(i).DataLabel.top, lblWidth:=.Points(i).DataLabel.Width, lblHeight:=.Points(i).DataLabel.Height, _
                                chtLeft:=pieChart.Chart.PlotArea.left, chtTop:=pieChart.Chart.PlotArea.top, chtWidth:=pieChart.Chart.PlotArea.Width, chtHeight:=pieChart.Chart.PlotArea.Height, percIncrease:=0.85)
                                

                'TODO: for whatever reason, this behaves differently when run in debug Mode
            .Points(i).DataLabel.left = leftOut
            .Points(i).DataLabel.top = topOut
            
        Next i
    
    End With
'    pieChart.OnAction = "ThisWorkbook.PrdHours_Click"
    
End Sub


    '*******work in progress********
Private Sub CreateBarChart(Xrange As Range, Yrange As Collection, empRange As Range, colorRange As Range)
    
    Set barChart = Me.Shapes.AddChart2(-1, xlBarStacked, left:=660, top:=ActiveWindow.VisibleRange.top + 360, Height:=170, Width:=415)
    barChart.Name = "Bar"
    'TODO: we should clear the contents out of the chart here, problems with the active cell
    
    If Xrange Is Nothing Or Yrange.Count = 0 Then
        Dim coll As Excel.Series
        For Each coll In barChart.Chart.SeriesCollection
            coll.XValues = vbEmpty
            coll.Values = vbEmpty
        Next coll
        
        barChart.Chart.ChartTitle.Caption = "NO DATA"
        barChart.Chart.ApplyChartTemplate (ThisWorkbook.path & "\templates\BarChartSum.crtx")
        Exit Sub
    End If
    
    barChart.Chart.ApplyChartTemplate (ThisWorkbook.path & "\templates\BarChartSum.crtx")
    barChart.Chart.ChartTitle.Caption = Xrange.Cells(1).Offset(-1, -1).Value

    Dim i As Integer
    Dim Yvalues As Range
    i = 1
    
    For Each Yvalues In Yrange
        barChart.Chart.SeriesCollection.NewSeries
        With barChart.Chart.SeriesCollection(i)
            .Name = empRange.Cells(i)
            .Values = Yvalues.Value
            .Format.Fill.ForeColor.RGB = colorRange.Cells(i).Value  'erorred here last
            
            If i = 1 Then
                .XValues = Xrange
            End If
        End With
        i = i + 1
    Next Yvalues

End Sub

Private Sub CreateTimeSeriesChart(Xrange As Range, Yrange As Range, empRange As Range, colors() As Variant)
    
    Set lineChart = Me.Shapes.AddChart2(-1, xlLineMarkers, left:=660, top:=ActiveWindow.VisibleRange.top + 360, Height:=170, Width:=415)
    lineChart.Name = "Line"
    
    If Xrange Is Nothing Or Yrange Is Nothing Then
        lineChart.Chart.SeriesCollection(1).XValues = vbEmpty
        lineChart.Chart.SeriesCollection(1).Values = vbEmpty
        lineChart.Chart.ChartTitle.Caption = "NO DATA"
        lineChart.Chart.ApplyChartTemplate (ThisWorkbook.path & "\templates\LineSeries.crtx")
        Exit Sub
    End If

    With lineChart.Chart
        .ChartTitle.Caption = "Production Qty Submitted"
        .SeriesCollection.NewSeries
        If Xrange.Count = 1 Then
            .SeriesCollection(1).XValues = Xrange
        Else
            .SeriesCollection(1).XValues = Xrange.Value
        End If
        .SeriesCollection(1).Values = Yrange
        .ApplyChartTemplate (ThisWorkbook.path & "\templates\LineSeries.crtx")
        
        Dim i As Integer
        i = 1
        Dim j As Integer
        Dim subCell As Range
        For Each subCell In empRange
            For j = 1 To UBound(colors)
                If subCell.Value = colors(j, 1) Then
                    .SeriesCollection(1).Points(i).Format.Fill.ForeColor.RGB = colors(j, 3)
                    GoTo contEmp
                End If
            Next j
contEmp:
            i = i + 1
        Next subCell
        
    End With

End Sub



'************************************************************
'***********   Worksheet Helper Functions   *****************
'************************************************************


    'Return column # of the header
Public Function GetCol(colName As String) As Integer
    Dim colRange As Range
    Set colRange = Range("A1:H1")
    On Error Resume Next
    GetCol = Application.WorksheetFunction.Match(colName, colRange, 0)
    If Err.Number <> 0 Then
        GetCol = 0
    End If
    On Error GoTo 0
End Function


    'All cells with Jobs in the "C" column
Public Function GetJobCells() As Range
    Dim activeCell As Range
    Set activeCell = Range("C1")
    Dim collectedRange As Range

    Dim missCount As Integer
        
    Do
        If activeCell.Value <> "" Then
            missCount = 0
            If activeCell.Interior.color <> RGB(128, 128, 128) Then
                If collectedRange Is Nothing Then
                    Set collectedRange = activeCell
                Else
                    Set collectedRange = Application.Union(collectedRange, activeCell)
                End If
            End If
        Else
            missCount = missCount + 1
        End If
        
        Set activeCell = activeCell.Offset(1, 0)
        
    Loop While (missCount < 2)
    
    Set GetJobCells = collectedRange

End Function

    'Need to determine the last machine/job we added
        'since we will just ignore selections below this
Private Function GetLastCell() As Range
    Set GetLastCell = Cells(Rows.Count, "C").End(xlUp)
End Function


    'What Job is currently Highlighted as Blue
    'Callign functions should check for Is Nothing
Private Function GetActiveJob() As Range
    Dim jobRange As Range
    Dim subCell As Range
    
    Set jobRange = GetJobCells()
    If jobRange Is Nothing Then Exit Function
    
    For Each subCell In jobRange
            'The active job is the blue highlighted cell
        If subCell.Interior.color = RGB(101, 215, 255) Then
            Set GetActiveJob = subCell
            Exit Function
        End If
    Next subCell

End Function

    'Get a new LEFT position for the data label
Private Function GetOuterLblLeft(lblLeft As Double, lblTop As Double, lblWidth As Double, lblHeight As Double, chtLeft As Double, chtTop As Double, _
                                            chtWidth As Double, chtHeight As Double, Optional percIncrease As Double) As Double
    Dim leftOffset As Double
    Dim relLeft As Double
    Dim relTop As Double
    If percIncrease = 0 Then percIncrease = 0.15
    
        'Normalize position relative to the chart center
    relLeft = Abs((lblLeft + (lblWidth / 2)) - (chtLeft + (chtWidth / 2)))
    relTop = Abs((lblTop + (lblHeight / 2)) - (chtTop + (chtHeight / 2)))
    
        'reposition Left proportial to the X distance from the Chart Center
    leftOffset = (relLeft / (relLeft + relTop)) * relLeft * percIncrease
    
    If lblLeft + (lblWidth / 2) > chtLeft + (chtWidth / 2) Then
        GetOuterLblLeft = lblLeft + leftOffset
    Else
            'Labels on left side of the chart need additional offset relative to the width of the label and proportional to left / top displacement
        GetOuterLblLeft = (lblLeft - (leftOffset - ((lblWidth * (relLeft / (relLeft + relTop))) * 0.3)))    'Also adding a custom offset factor at the end here
    End If
    
End Function

    'Get a new TOP position for the data label
Private Function GetOuterLblTop(lblLeft As Double, lblTop As Double, lblWidth As Double, lblHeight As Double, chtLeft As Double, chtTop As Double, _
                                            chtWidth As Double, chtHeight As Double, Optional percIncrease As Double) As Double
    Dim topOffset As Double
    Dim relLeft As Double
    Dim relTop As Double
    If percIncrease = 0 Then percIncrease = 0.15
    
        'Normalize position relative to the chart center
    relLeft = Abs((lblLeft + (lblWidth / 2)) - (chtLeft + (chtWidth / 2)))
    relTop = Abs((lblTop + (lblHeight / 2)) - (chtTop + (chtHeight / 2)))
    
        'reposition Top proportial to the Y distance from the Chart Center
    topOffset = (relTop / (relLeft + relTop)) * relTop * percIncrease
    
    If lblTop + (lblHeight / 2) > chtTop + (chtHeight / 2) Then
        GetOuterLblTop = lblTop + topOffset
    Else
            'Labels on top side of the chart need additional offset relative to the height of the label and proportional to left / top displacement
        GetOuterLblTop = lblTop - topOffset - ((lblHeight * (relTop / (relLeft + relTop))) * 0.5)   'Also adding a custom offset factor at the end here
    End If
    
End Function










